const { Telegraf, Markup, session } = require("telegraf");
const express = require("express");
const fs = require("fs-extra");
const path = require("path");
const os = require("os");
const sqlite3 = require("sqlite3").verbose();
const mammoth = require("mammoth");
const gpt4all = require("gpt4all");
const fuzzysort = require('fuzzysort'); // –î–æ–±–∞–≤–ª–µ–Ω–æ
const languageToolApi = require('languagetool-api');

// --- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –ø—Ä–∏ require ---
function safeRequire(modulePath) {
  try {
    return require(modulePath);
  } catch (e) {
    console.error(`[FATAL] –û—à–∏–±–∫–∞ –ø—Ä–∏ require('${modulePath}'):`, e);
    throw e;
  }
}

const { exportCacheToJsonFile, uploadCacheJsonToYadisk } = safeRequire("./modules/cache_export");
const ui = safeRequire("./modules/ui_messages"); // –ù–æ–≤—ã–π –º–æ–¥—É–ª—å UI-—Å–æ–æ–±—â–µ–Ω–∏–π
const logger = safeRequire("./modules/logger"); // <-- –¥–æ–±–∞–≤–ª–µ–Ω winston logger
const { recognizeText } = safeRequire("./modules/ocr"); // OCR-–º–æ–¥—É–ª—å
const { convertDocxToPdf } = safeRequire("./modules/docx2pdf");
const { saveToCacheHistory, getAllCacheQuestions, fuzzyFindInCache } = safeRequire("./modules/cache");
const { postprocessLanguageTool } = require('./modules/ocr'); // –ò–º–ø–æ—Ä—Ç –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∏ LanguageTool

require("dotenv").config();

const YaDiskService = require("./services/yadisk_service");

const PORT = process.env.PORT || 3000;
const BOT_TOKEN = process.env.BOT_TOKEN;
const modelName = "Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf";
const modelDir = path.join(os.homedir(), ".cache", "gpt4all");
const materialsPath = path.join(__dirname, "materials");
const cachePath = path.join(__dirname, "cache");
const tempPath = path.join(__dirname, "temp");
const gpt4allPath = path.join(modelDir, modelName);
const gpt4allCachePath = path.join(gpt4allPath, "cache");
const bot = new Telegraf(BOT_TOKEN);
bot.use(session());
const app = express();
app.use("/static", express.static(path.join(__dirname, "static")));

// –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø–∞–ø–∫–∞ cache —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
fs.ensureDirSync(cachePath);

// –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
const db = new sqlite3.Database("database.sqlite", (err) => {
  if (err) {
    logger.error("DB Error: " + err.message);
    process.exit(1); // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å, –µ—Å–ª–∏ –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è
  } else {
    try {
      initDatabase();
    } catch (error) {
      logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: " + error.message);
    }
  }
});

function initDatabase() {
  db.run(`CREATE TABLE IF NOT EXISTS gpt_cache (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    prompt TEXT UNIQUE,
    response TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )`);
}

let gpt4allModel = null;
async function initGPT4AllModel() {
  const model = await gpt4all.loadModel(modelName);
  return {
    generate: async (prompt) => {
      const options = {
        maxTokens: 32,
        temp: 1.5,
        topK: 1,
        topP: 0.1,
        repeatPenalty: 1.0,
        batchSize: 1,
      };
      return (await model.generate(prompt, options)).text;
    },
  };
}

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ—á–µ—Ä–µ–¥—å –∑–∞–¥–∞—á –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫—ç—à–∞
const cacheQueue = [];
let isCacheProcessing = false;

// Fuzzy –ø–æ–∏—Å–∫ –ø–æ –∫—ç—à—É –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫–µ
async function fuzzyFindInYandexDisk(question) {
  try {
    // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª –∫—ç—à–∞ —Å –Ø.–î–∏—Å–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, cache/dataset.json)
    const remotePath = "/bot_cache/dataset.json";
    const localPath = path.join(cachePath, "dataset.json");
    await yadisk.downloadFileByPath(remotePath, localPath);

    if (!fs.existsSync(localPath)) return null;
    const data = JSON.parse(fs.readFileSync(localPath, "utf8"));
    if (!Array.isArray(data)) return null;

    // data: [{ prompt, response }, ...]
    const results = fuzzysort.go(question, data, { key: 'prompt', threshold: -1000 });
    if (results.length > 0 && results[0].score > -1000) {
      return results[0].obj.response;
    }
    return null;
  } catch (err) {
    logger.error(`[YADISK CACHE] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ${err.message}`);
    notifyAdmin(`[YADISK CACHE] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ${err.message}`);
    return null;
  }
}

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –∏ –æ—Ç—á—ë—Ç–æ–≤ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (—á–µ—Ä–µ–∑ ADMIN_ID)
const ADMIN_ID = process.env.ADMIN_ID;
function notifyAdmin(message) {
  if (ADMIN_ID) bot.telegram.sendMessage(ADMIN_ID, `[ADMIN LOG]\n${message}`);
  logger.info(`[ADMIN NOTIFY] ${message}`);
}

// –ü—Ä–æ–≥—Ä–µ—Å—Å –∏ —Å—Ç–∞—Ç—É—Å
async function sendProgress(ctx, text) {
  try { await ctx.reply(text); } catch {}
  notifyAdmin(text);
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª–∏–Ω–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ (—Ä–∞–∑–±–∏–≤–∫–∞ –Ω–∞ —á–∞—Å—Ç–∏)
function splitTextByLength(text, maxLength = 700) {
  const parts = [];
  let i = 0;
  while (i < text.length) {
    parts.push(text.substring(i, i + maxLength));
    i += maxLength;
  }
  return parts;
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫—ç—à–∞ —Å –æ—á–µ—Ä–µ–¥—å—é –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
async function processCacheQueue() {
  if (isCacheProcessing || cacheQueue.length === 0) return;
  isCacheProcessing = true;

  const { ctx } = cacheQueue.shift();
  try {
    await sendProgress(ctx, ui.processingFile);
    const files = await yadisk.syncMaterials();
    if (!files.length) {
      await sendProgress(ctx, ui.error("–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∫—ç—à–∞."));
      isCacheProcessing = false;
      return;
    }

    const random = files[Math.floor(Math.random() * files.length)];
    const filePath = path.join(materialsPath, random);
    await sendProgress(ctx, ui.processingFile + `\nüìÑ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ñ–∞–π–ª: ${random}`);
    const content = await parseDocxToText(filePath);

    // –†–∞–∑–±–∏–≤–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –Ω–∞ —á–∞—Å—Ç–∏
    const parts = splitTextByLength(content, 700);
    let allSummaries = [];
    for (let idx = 0; idx < parts.length; idx++) {
      await sendProgress(ctx, ui.generatingPrompt(idx + 1, parts.length));
      const prompt = `–¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç –ø–æ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ-–∫–∞—Å—Å–æ–≤–æ–π —Ç–µ—Ö–Ω–∏–∫–µ, 1–° –∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –±–∏–∑–Ω–µ—Å–∞. 
–ò–∑—É—á–∏ –º–∞—Ç–µ—Ä–∏–∞–ª –Ω–∏–∂–µ –∏ –≤—ã–¥–µ–ª–∏ —Ç–æ–ª—å–∫–æ —Ç–µ —Ç–µ–∑–∏—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –ø–æ–ª–µ–∑–Ω—ã —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—É –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏. –ù–µ –ø–µ—Ä–µ—á–∏—Å–ª—è–π –æ–±—â–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –æ—Å–Ω–æ–≤—ã –∏ –±–∞–∑–æ–≤—ã–µ —Ñ–∞–∫—Ç—ã. –£–ø–æ–º–∏–Ω–∞–π —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ, —Å–ª–æ–∂–Ω—ã–µ –∏–ª–∏ –º–∞–ª–æ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –¥–µ—Ç–∞–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—É. –ö–∞–∂–¥—ã–π —Ç–µ–∑–∏—Å ‚Äî —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.

${parts[idx]}`;
      if (!gpt4allModel) gpt4allModel = await initGPT4AllModel();
      await sendProgress(ctx, ui.promptSent);
      const summary = await gpt4allModel.generate(prompt);
      await sendProgress(ctx, ui.modelAnswerReceived);
      allSummaries.push(summary);

      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∑–∏—Å—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–ª–æ–∫–∞
      const thesisList = summary
        .split(/\n+/)
        .map(t => t.trim())
        .filter(Boolean)
        .map((t, i) => `üìå <b>${i + 1}.</b> ${t}`)
        .join('\n\n');
      await ctx.replyWithHTML(
        `‚úÖ <b>–¢–µ–∑–∏—Å—ã –ø–æ —á–∞—Å—Ç–∏ ${idx + 1}:</b>\n\n${thesisList}`
      );
    }
    const finalSummary = allSummaries.join("\n---\n");

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –≥–µ–Ω–µ—Ä–∞—Ü–∏–π (–∫–∞–∂–¥—ã–π –∑–∞–ø—É—Å–∫ ‚Äî –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å)
    await sendProgress(ctx, ui.savingToCache);
    saveToCacheAndSync(random, finalSummary, ctx);

    // –ö—Ä–∞—Å–∏–≤–æ –æ—Ñ–æ—Ä–º–ª—è–µ–º —Ç–µ–∑–∏—Å—ã –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –±–æ—Ç
    const thesisList = finalSummary
      .split(/\n+/)
      .map(t => t.trim())
      .filter(Boolean)
      .map((t, i) => `üìå <b>${i + 1}.</b> ${t}`)
      .join('\n\n');

    await ctx.replyWithHTML(
      `‚úÖ <b>–ö—Ä–∞—Ç–∫–æ–µ –∏–∑–ª–æ–∂–µ–Ω–∏–µ (—Ç–µ–∑–∏—Å—ã):</b>\n\n${thesisList}`
    );

    await sendProgress(ctx, ui.cacheSynced);
    notifyAdmin(`–ö—ç—à —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Ñ–∞–π–ª–∞: ${random}`);

  } catch (err) {
    await sendProgress(ctx, ui.error(err.message));
    notifyAdmin(`–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫—ç—à–∞: ${err.message}`);
    logger.error(`–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫—ç—à–∞: ${err.message}`);
  } finally {
    isCacheProcessing = false;
    if (cacheQueue.length > 0) processCacheQueue();
  }
}

// –°—Ç–∞—Ä—ã–π –≤–∞—Ä–∏–∞–Ω—Ç: –æ–±—ã—á–Ω—ã–π –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç-–∑–∞–ø—Ä–æ—Å –±–µ–∑ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞
async function streamAIResponse(prompt, ctx) {
  try {
    if (!gpt4allModel) gpt4allModel = await initGPT4AllModel();
    const result = await gpt4allModel.generate(prompt);
    await ctx.reply("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç:\n" + result);
  } catch (error) {
    await ctx.reply(ui.error(error.message));
    logger.error("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞: " + error.message);
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ñ–∞–π–ª–∞–º–∏
async function parseDocxToText(filePath) {
  try {
    const result = await mammoth.extractRawText({ path: filePath });
    return result.value.trim();
  } catch (error) {
    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ ${filePath}: ${error.message}`);
    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏–∑ —Ñ–∞–π–ª–∞.");
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤
async function generateAIQuestions(text) {
  try {
    const maxInputLength = 700;
    const truncatedText = text.length > maxInputLength ? text.substring(0, maxInputLength) + "..." : text;
    const prompt = `–°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –æ–¥–∏–Ω –∫–æ—Ä–æ—Ç–∫–∏–π –≤–æ–ø—Ä–æ—Å —Å 4 –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –æ—Ç–≤–µ—Ç–æ–≤ –ø–æ —Ç–µ–∫—Å—Ç—É –Ω–∏–∂–µ. –û—Ç–º–µ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç.\n–í–û–ü–†–û–°:\n–ê)\n–ë)\n–í)\n–ì)\n–ü–†–ê–í–ò–õ–¨–ù–´–ô:`;
    if (!gpt4allModel) gpt4allModel = await initGPT4AllModel();

    return await gpt4allModel.generate(`${prompt}\n\n${truncatedText}`);
  } catch (error) {
    logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤: " + error.message);
    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã.");
  }
}

function parseTestResponse(response) {
  const lines = response.split("\n");
  return {
    question: lines[0]?.replace("–í–û–ü–†–û–°:", "").trim(),
    answers: {
      –ê: lines[1]?.slice(3).trim(),
      –ë: lines[2]?.slice(3).trim(),
      –í: lines[3]?.slice(3).trim(),
      –ì: lines[4]?.slice(3).trim(),
    },
    correct: lines[5]?.replace("–ü–†–ê–í–ò–õ–¨–ù–´–ô:", "").trim(),
  };
}

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –∫–æ–Ω—Å–æ–ª—å –∏ –≤ –±–æ—Ç
function logAndNotify(message, ctx = null) {
  const logMessage = `[${new Date().toISOString()}] ${message}`;
  logger.info(logMessage); // –õ–æ–≥–∏—Ä—É–µ–º –≤ –∫–æ–Ω—Å–æ–ª—å
  if (ctx) ctx.reply(message); // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –±–æ—Ç
}

// –û—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é
function mainMenuKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback("üìÇ –ú–∞—Ç–µ—Ä–∏–∞–ª—ã", "materials")],
    [Markup.button.callback("ü§ñ –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ò–ò", "ask_ai")],
    [Markup.button.callback("üìä –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ö—ç—à–∞", "generate_cache")],
    [Markup.button.callback("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", "settings")],
    [Markup.button.callback("üîÑ –†–µ–∑–µ—Ç", "reset")],
  ]);
}

// –•—Ä–∞–Ω–∏–º –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
const userStates = {};
const userContexts = {}; // userId: [ {role: "user"/"assistant", content: "..."} ]

bot.start((ctx) => ctx.reply("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:", mainMenuKeyboard()));
bot.action("reset", async (ctx) => ctx.reply("–ò—Å—Ç–æ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞.", mainMenuKeyboard()));

// –ö–Ω–æ–ø–∫–∞ "–ú–∞—Ç–µ—Ä–∏–∞–ª—ã" ‚Äî –≤—ã–≤–æ–¥–∏—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤
bot.action("materials", async (ctx) => {
  try {
    const files = await fs.readdir(materialsPath);
    const docxFiles = files.filter(f => f.endsWith(".docx"));
    if (!docxFiles.length) {
      return ctx.reply("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤.");
    }
    const buttons = docxFiles.map(f =>
      [Markup.button.callback(f, `material_${encodeURIComponent(f)}`)]
    );
    await ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç–µ—Ä–∏–∞–ª:", Markup.inlineKeyboard(buttons));
  } catch (err) {
    logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤: " + err.message);
    await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤.");
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª
bot.action(/material_(.+)/, async (ctx) => {
  const fileName = decodeURIComponent(ctx.match[1]);
  const docxPath = path.join(materialsPath, fileName);
  const pdfName = fileName.replace(/\.docx$/i, ".pdf");
  const pdfPath = path.join(cachePath, pdfName);

  try {
    await ctx.answerCbQuery(); // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ callback
    await ctx.editMessageReplyMarkup(null); // –£–¥–∞–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    await ctx.reply(ui.processingFile);
    
    await convertDocxToPdf(docxPath, pdfPath);
    await ctx.replyWithDocument({ source: pdfPath, filename: pdfName });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞
    await ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", mainMenuKeyboard());
  } catch (err) {
    logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ PDF: " + err.message);
    await ctx.reply(ui.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ PDF: " + err.message));
    await ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", mainMenuKeyboard());
  }
});

// –ö–Ω–æ–ø–∫–∞ "–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ò–ò"
bot.action("ask_ai", async (ctx) => {
  userStates[ctx.from.id] = "awaiting_ai_prompt";
  if (!userContexts[ctx.from.id]) userContexts[ctx.from.id] = [];
  await ctx.reply("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –¥–ª—è –ò–ò:");
});

// –ü–æ–¥—Ä–æ–±–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å–≤–µ—Ä–∫–∏ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–ø—Ä–æ—Å–∞ –≤ –∫—ç—à –∏ –Ω–∞ –Ø.–î–∏—Å–∫
bot.on("text", async (ctx) => {
  const userId = ctx.from.id;
  if (userStates[userId] === "awaiting_ai_prompt" || userStates[userId] === "chatting_ai") {
    userStates[userId] = "chatting_ai";
    if (!userContexts[userId]) userContexts[userId] = [];
    userContexts[userId].push({ role: "user", content: ctx.message.text });

    logger.info(`[AI Q] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–¥–∞–ª –≤–æ–ø—Ä–æ—Å: "${ctx.message.text}"`);
    notifyAdmin(`[AI Q] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–¥–∞–ª –≤–æ–ø—Ä–æ—Å: "${ctx.message.text}"`);

    // 1. Fuzzy –ø–æ–∏—Å–∫ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º –∫—ç—à–µ
    await ctx.reply(ui.searchingLocalCache);
    getAllCacheQuestions((err, rows) => {
      if (err) {
        logger.error(`[CACHE] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—ç—à–∞: ${err.message}`);
        notifyAdmin(`[CACHE] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—ç—à–∞: ${err.message}`);
        ctx.reply(ui.error("–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ –∫—ç—à–µ."));
        return;
      }
      logger.info(`[CACHE] –í –∫—ç—à–µ ${rows.length} –∑–∞–ø–∏—Å–µ–π. –ù–∞—á–∏–Ω–∞–µ–º fuzzy –ø–æ–∏—Å–∫...`);
      notifyAdmin(`[CACHE] –í –∫—ç—à–µ ${rows.length} –∑–∞–ø–∏—Å–µ–π. –ù–∞—á–∏–Ω–∞–µ–º fuzzy –ø–æ–∏—Å–∫...`);

      const results = fuzzysort.go(ctx.message.text, rows, { key: 'prompt', threshold: -1000 });
      if (results.length > 0) {
        logger.info(`[CACHE] –õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: "${results[0].obj.prompt}" (score: ${results[0].score})`);
        notifyAdmin(`[CACHE] –õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: "${results[0].obj.prompt}" (score: ${results[0].score})`);
      } else {
        logger.info(`[CACHE] –°–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`);
        notifyAdmin(`[CACHE] –°–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`);
      }

      if (results.length > 0 && results[0].score > -1000) {
        ctx.reply("üîé –û—Ç–≤–µ—Ç –∏–∑ –∫—ç—à–∞ (–ø–æ–∏—Å–∫ –ø–æ –ø–æ—Ö–æ–∂–µ—Å—Ç–∏):\n" + results[0].obj.response);
        logger.info(`[CACHE] –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏–∑ –∫—ç—à–∞.`);
        notifyAdmin(`[CACHE] –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏–∑ –∫—ç—à–∞.`);
        return;
      }

      // 2. Fuzzy –ø–æ–∏—Å–∫ –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫–µ
      (async () => {
        await ctx.reply(ui.searchingYadisk);
        const yadiskAnswer = await fuzzyFindInYandexDisk(ctx.message.text);
        if (yadiskAnswer) {
          ctx.reply("üîé –û—Ç–≤–µ—Ç –∏–∑ –∫—ç—à–∞ –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫–µ:\n" + yadiskAnswer);
          logger.info(`[YADISK CACHE] –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏–∑ –∫—ç—à–∞ –Ω–∞ –Ø.–î–∏—Å–∫–µ.`);
          notifyAdmin(`[YADISK CACHE] –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏–∑ –∫—ç—à–∞ –Ω–∞ –Ø.–î–∏—Å–∫–µ.`);
          return;
        }

        // 3. –ï—Å–ª–∏ –Ω–µ—Ç –Ω–∏ –≤ –æ–¥–Ω–æ–º –∫—ç—à–µ ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –º–æ–¥–µ–ª—å
        try {
          logger.info(`[AI] –û—Ç–≤–µ—Ç–∞ –≤ –∫—ç—à–µ –Ω–µ—Ç, –æ–±—Ä–∞—â–∞–µ–º—Å—è –∫ –º–æ–¥–µ–ª–∏...`);
          notifyAdmin(`[AI] –û—Ç–≤–µ—Ç–∞ –≤ –∫—ç—à–µ –Ω–µ—Ç, –æ–±—Ä–∞—â–∞–µ–º—Å—è –∫ –º–æ–¥–µ–ª–∏...`);
          if (!gpt4allModel) gpt4allModel = await initGPT4AllModel();

          const contextWindow = 10;
          const context = userContexts[userId].slice(-contextWindow);
          const prompt = context.map(m => (m.role === "user" ? `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${m.content}` : `–ò–ò: ${m.content}`)).join('\n') + "\n–ò–ò:";

          await ctx.reply(ui.promptSent);
          const result = await gpt4allModel.generate(prompt);
          userContexts[userId].push({ role: "assistant", content: result });

          await ctx.reply(ui.answerSaved);
          saveToCacheAndSync(ctx.message.text, result, ctx);

          ctx.reply(result || "–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç –º–æ–¥–µ–ª–∏.");
          logger.info(`[AI] –û—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ –∫—ç—à.`);
          notifyAdmin(`[AI] –û—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ –∫—ç—à.`);
        } catch (error) {
          ctx.reply(ui.error(error.message));
          logger.error(`[AI] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${error.message}`);
          notifyAdmin(`[AI] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${error.message}`);
        }
      })();
    });
  }
});

// --- OCR —à–∞–±–ª–æ–Ω—ã: —Ç–æ–ø-10 –ª—É—á—à–∏—Ö ---
const ocrTemplates = [
  { pre: 'cropTextBlock', post: 'strong', name: 'cropTextBlock+strong' },
  { pre: 'cropTextBlock', post: 'medium', name: 'cropTextBlock+medium' },
  { pre: 'cropTextBlock', post: 'weak', name: 'cropTextBlock+weak' },
  { pre: 'strong', post: 'medium', name: 'strong+medium' },
  { pre: 'strong', post: 'strong', name: 'strong+strong' },
  { pre: 'strong', post: 'weak', name: 'strong+weak' },
  { pre: 'medium', post: 'strong', name: 'medium+strong' },
  { pre: 'medium', post: 'medium', name: 'medium+medium' },
  { pre: 'medium', post: 'weak', name: 'medium+weak' },
  { pre: 'strongV3', post: 'strong', name: 'strongV3+strong' }
];

// --- –ï–¥–∏–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –≤—Å–µ—Ö —à–∞–±–ª–æ–Ω–æ–≤ ---
const ocrTemplatesKeyboard = [[{ text: '–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤—Å–µ–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏', callback_data: 'ocr_all_templates' }]];

// –ü—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å –∏ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –∫–Ω–æ–ø–∫—É
bot.on(["photo"], async (ctx) => {
  const userId = ctx.from.id;
  if (userStates[userId] === "awaiting_ai_prompt" || userStates[userId] === "chatting_ai") {
    userStates[userId] = "chatting_ai";
    const photo = ctx.message.photo.pop();
    const fileId = photo.file_id;
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const filePath = path.join(tempPath, `${userId}_${Date.now()}.jpg`);
    await fs.ensureDir(tempPath);
    const res = await fetch(fileLink.href);
    const buffer = await res.arrayBuffer();
    await fs.writeFile(filePath, Buffer.from(buffer));
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å –∫ —Ñ–æ—Ç–æ –≤ —Å–µ—Å—Å–∏—é
    if (!ctx.session) ctx.session = {};
    ctx.session.lastPhotoPath = filePath;
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –∏–∑ 1 –∫–Ω–æ–ø–∫–∏
    await ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–±—Ä–∞–±–æ—Ç–∫–∏ OCR:", Markup.inlineKeyboard(ocrTemplatesKeyboard));
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤—Å–µ–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏"
bot.action('ocr_all_templates', async (ctx) => {
  try {
    const filePath = ctx.session && ctx.session.lastPhotoPath;
    if (!filePath || !fs.existsSync(filePath)) {
      await ctx.reply('–ù–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ñ–æ—Ç–æ –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è.');
      return;
    }
    await ctx.reply('–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –≤—Å–µ–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏...');
    const allResults = [];
    for (let i = 0; i < ocrTemplates.length; ++i) {
      const tpl = ocrTemplates[i];
      logger.info(`[BOT] –°—Ç–∞—Ä—Ç —à–∞–±–ª–æ–Ω–∞ ${i+1}: ${tpl.name}`);
      await ctx.reply(`–ò—Å–ø–æ–ª—å–∑—É—é —à–∞–±–ª–æ–Ω ${i+1}: ${tpl.name}`);
      let tesseractText = '';
      try {
        const { recognizeTextWithTemplateTesseract } = require("./modules/ocr");
        tesseractText = await recognizeTextWithTemplateTesseract(filePath, tpl.pre, tpl.post);
        logger.info(`[BOT] –†–µ–∑—É–ª—å—Ç–∞—Ç —à–∞–±–ª–æ–Ω–∞ ${i+1}: ${tpl.name}: ${tesseractText}`);
      } catch (e) {
        tesseractText = `–û—à–∏–±–∫–∞ Tesseract: ${e.message}`;
        logger.error(`[BOT] –û—à–∏–±–∫–∞ —à–∞–±–ª–æ–Ω–∞ ${i+1}: ${tpl.name}: ${e.message}`);
      }
      allResults.push({ tplName: tpl.name, text: tesseractText });
      try {
        await ctx.replyWithHTML(
          `<b>–®–∞–±–ª–æ–Ω ${i+1}: ${tpl.name}</b>\n\n<b>Tesseract:</b>\n<pre>${escapeHTML(tesseractText)}</pre>`
        );
        logger.info(`[BOT] –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ —à–∞–±–ª–æ–Ω—É ${i+1}: ${tpl.name}`);
      } catch (err) {
        logger.error(`[BOT] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞ –ø–æ —à–∞–±–ª–æ–Ω—É ${i+1}: ${tpl.name}: ${err.message}`);
      }
    }
    // --- –ù–æ–≤—ã–π —ç—Ç–∞–ø: "—Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–±–æ—Ä–∫–∞" –∏–∑ –≤—Å–µ—Ö —à–∞–±–ª–æ–Ω–æ–≤ ---
    const semanticResult = semanticOcrAssemble(allResults);
    logger.info(`[BOT] –ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π —Å–±–æ—Ä–∫–∏: ${semanticResult}`);
    // --- –û—á–∏—Å—Ç–∫–∞ —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª—å–Ω—ã–π LanguageTool ---
    const cleanedSemantic = await postprocessLanguageTool(semanticResult);
    logger.info(`[BOT] –ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—Å–ª–µ LanguageTool: ${cleanedSemantic}`);
    // --- –§–∏–Ω–∞–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ –¥–ª—è Telegram ---
    const humanResult = humanReadableAssemble(cleanedSemantic);
    logger.info(`[BOT] –ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è Telegram: ${humanResult}`);
    // --- –û—Ü–µ–Ω–∫–∞ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ OCR ---
    function evalHumanReadableScore(text) {
      if (!text || typeof text !== 'string') return 0;
      // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –∏ —Å—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      if (!lines.length) return 0;
      const avgLen = lines.reduce((a, b) => a + b.length, 0) / lines.length;
      // –î–æ–ª—è —Ä—É—Å—Å–∫–∏—Ö –±—É–∫–≤
      const totalChars = text.length;
      const ruChars = (text.match(/[–ê-–Ø–∞-—è–Å—ë]/g) || []).length;
      const ruRatio = ruChars / (totalChars || 1);
      // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ "–º—É—Å–æ—Ä–Ω—ã—Ö" —Å—Ç—Ä–æ–∫ (–æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏—Ö, —Å –±–æ–ª—å—à–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤)
      const noisyLines = lines.filter(l => l.length < 5 || (l.replace(/[–ê-–Ø–∞-—è–Å—ë0-9]/gi, '').length / l.length) > 0.5).length;
      // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—Ç—Ä–æ–∫
      const uniqLines = new Set(lines).size;
      // –ë–æ–Ω—É—Å –∑–∞ –Ω–∞–ª–∏—á–∏–µ —Ç–∏–ø–∏—á–Ω—ã—Ö —Å–ª–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ", "—Å–∫–∞—á–∞–π—Ç–µ", "–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", "–º–∞–≥–∞–∑–∏–Ω")
      const bonusWords = ["–ê–ö–¢–ò–í–ò–†–£–ô–¢–ï", "–°–ö–ê–ß–ê–ô–¢–ï", "–ü–†–ò–õ–û–ñ–ï–ù–ò–ï", "–ú–ê–ì–ê–ó–ò–ù", "–°–ï–†–í–ò–°–´", "–≠–í–û–¢–û–†"];
      let bonus = 0;
      for (const w of bonusWords) if (text.toUpperCase().includes(w)) bonus += 0.1;
      // –ò—Ç–æ–≥–æ–≤–∞—è —Ñ–æ—Ä–º—É–ª–∞: –±–æ–ª—å—à–µ —Ä—É—Å—Å–∫–∏—Ö –±—É–∫–≤, –º–µ–Ω—å—à–µ –º—É—Å–æ—Ä–∞, –±–æ–ª—å—à–µ —Å—Ç—Ä–æ–∫, –±–æ–ª—å—à–µ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏, –±–æ–Ω—É—Å –∑–∞ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
      return (
        ruRatio * 2 +
        Math.min(avgLen / 20, 1) +
        Math.min(lines.length / 10, 1) +
        Math.min(uniqLines / lines.length, 1) +
        bonus -
        noisyLines * 0.2
      );
    }

    // --- –í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ OCR ---
    function selectBestOcrResult(allResults, semanticResult, cleanedSemantic, humanResult) {
      // –û—Ü–µ–Ω–∏–≤–∞–µ–º –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
      const candidates = [];
      allResults.forEach((r, i) => candidates.push({
        text: r,
        label: `–®–∞–±–ª–æ–Ω ${i + 1}`,
        score: evalHumanReadableScore(r)
      }));
      candidates.push({ text: semanticResult, label: '–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–±–æ—Ä–∫–∞', score: evalHumanReadableScore(semanticResult) });
      candidates.push({ text: cleanedSemantic, label: '–ü–æ—Å–ª–µ LanguageTool', score: evalHumanReadableScore(cleanedSemantic) });
      candidates.push({ text: humanResult, label: '–§–∏–Ω–∞–ª—å–Ω—ã–π (humanReadableAssemble)', score: evalHumanReadableScore(humanResult) });
      // –í—ã–±–∏—Ä–∞–µ–º —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º score
      candidates.sort((a, b) => b.score - a.score);
      logger.info(`[BOT] –õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${candidates[0].label} (–æ—Ü–µ–Ω–∫–∞: ${candidates[0].score.toFixed(2)})`);
      logger.info(`[BOT] –õ—É—á—à–∏–π —Ç–µ–∫—Å—Ç:\n${candidates[0].text}`);
      return candidates[0].text;
    }

    const bestResult = selectBestOcrResult(allResults.map(r => r.text), semanticResult, cleanedSemantic, humanResult);
    sendBestOcrResult(ctx, bestResult);
  } catch (e) {
    logger.error(`[BOT] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ ocr_all_templates: ${e.message}`);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏: ' + e.message);
  }
});

// --- –£–º–Ω–∞—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–±–æ—Ä–∫–∞: —Ä–∞–∑–±–∏–≤–∫–∞, —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è, —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ ---
function semanticOcrAssemble(results) {
  // 1. –†–∞–∑–±–∏–≤–∞–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –Ω–∞ —Å–º—ã—Å–ª–æ–≤—ã–µ –±–ª–æ–∫–∏
  function splitToBlocks(text) {
    return text
      .split(/[\n\r\f\v\u2028\u2029\u0085]+/)
      .flatMap(line =>
        line
          .split(/\s{2,}|\||:|‚Äî|‚Äì|‚Äî|\.|,|;/) // –¥–µ–ª–∏–º –ø–æ –¥–≤–æ–π–Ω—ã–º –ø—Ä–æ–±–µ–ª–∞–º, |, :, —Ç–∏—Ä–µ, —Ç–æ—á–∫–∞–º, –∑–∞–ø—è—Ç—ã–º, —Ç–æ—á–∫–∞–º —Å –∑–∞–ø—è—Ç–æ–π
          .map(x => x.trim())
      )
      .filter(Boolean);
  }
  // 2. –§–∏–ª—å—Ç—Ä—É–µ–º: —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫–∏ —Å >=2 —Ä—É—Å—Å–∫–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ –¥–ª–∏–Ω–æ–π >=4, –¥–æ–ª—è –±—É–∫–≤ >0.6
  function isClean(line) {
    const words = (line.match(/[–∞-—è–ê-–Ø—ë–Å]{4,}/g) || []);
    const letterFrac = (line.replace(/[^–∞-—è–ê-–Ø—ë–Å]/g, '').length / (line.length || 1));
    return words.length >= 2 && letterFrac > 0.6;
  }
  // 3. –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –±–ª–æ–∫–∏
  let allBlocks = [];
  results.forEach(r => {
    allBlocks = allBlocks.concat(splitToBlocks(r.text));
  });
  // 4. –§–∏–ª—å—Ç—Ä—É–µ–º –º—É—Å–æ—Ä
  allBlocks = allBlocks.filter(isClean);
  // 5. –°—á–∏—Ç–∞–µ–º —á–∞—Å—Ç–æ—Ç—É
  const freq = {};
  allBlocks.forEach(line => { freq[line] = (freq[line] || 0) + 1; });
  // 6. –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –∏ –¥–ª–∏–Ω–µ
  allBlocks = [...new Set(allBlocks)];
  allBlocks.sort((a, b) => freq[b] - freq[a] || b.length - a.length);
  // 7. –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏ –∏ –ø–æ—Ö–æ–∂–∏–µ —Å—Ç—Ä–æ–∫–∏ (fuzzysort, threshold -30)
  const finalLines = [];
  allBlocks.forEach(line => {
    if (!finalLines.some(existing => {
      const res = fuzzysort.single(line, [existing], { threshold: -30 });
      return res && res.score > -30;
    })) {
      finalLines.push(line);
    }
  });
  // 8. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º (–µ—Å–ª–∏ –µ—Å—Ç—å)
  const keywords = [
    '–ò–ü', '1–°', '–ë–£–•–ì–ê–õ–¢–ï–†–ò–Ø', '–î–µ–Ω–µ–∂–Ω—ã–π —è—â–∏–∫', '–§–æ—Ä—Ç', '–ø–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–π', '—Ä—É–±', '–ü–æ–¥–ø–∏—Å—å', '–¥–∞—Ç–∞', '–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è', '–ø—Ä–∏–Ω—Ç–µ—Ä', '—Å–∫–∞–Ω–µ—Ä', '–≤–µ—Å–æ–≤–æ–µ', '—Ç–µ—Ä–º–∏–Ω–∞–ª', 'POS'
  ];
  finalLines.sort((a, b) => {
    const ka = keywords.findIndex(k => a.toLowerCase().includes(k.toLowerCase()));
    const kb = keywords.findIndex(k => b.toLowerCase().includes(k.toLowerCase()));
    if (ka !== kb) return (ka === -1 ? 100 : ka) - (kb === -1 ? 100 : kb);
    return b.length - a.length;
  });
  return finalLines.join('\n');
}

// --- –§–∏–Ω–∞–ª—å–Ω–∞—è "—á–µ–ª–æ–≤–µ–∫–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è" —Å–±–æ—Ä–∫–∞ –¥–ª—è Telegram ---
function humanReadableAssemble(text) {
  // –ö–ª—é—á–µ–≤—ã–µ —Å–º—ã—Å–ª–æ–≤—ã–µ –±–ª–æ–∫–∏ –≤ –Ω—É–∂–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å)
  const keyPhrases = [
    "1–° –ë–£–•–ì–ê–õ–¢–ï–†–ò–Ø",
    "–ê–í–¢–û–ú–ê–¢–ò–ó–ê–¶–ò–Ø –¢–û–†–ì–û–í–õ–ò",
    "–ü–†–ò–ù–¢–ï–†–´ –≠–¢–ò–ö–ï–¢–û–ö",
    "–°–ö–ê–ù–ï–†–´ –®–¢–†–ò–•-–ö–û–î–ê",
    "–í–ï–°–û–í–û–ï –û–ë–û–†–£–î–û–í–ê–ù–ò–ï",
    "–¢–ï–†–ú–ò–ù–ê–õ–´ –°–ë–û–†–ê –î–ê–ù–ù–´–•",
    "POS-—Å–∏—Å—Ç–µ–º—ã"
  ];
  // –ü—Ä–∏–≤–µ—Å—Ç–∏ –∫ –≤–µ—Ä—Ö–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É, —É–±—Ä–∞—Ç—å –º—É—Å–æ—Ä–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
  const lines = text.split(/\r?\n|['"‚Äú‚Äù‚Äò‚Äô‚Äî‚Äì‚Ä¶¬∑‚Ä¢,.;:!?()\[\]{}]/)
    .map(s => s.trim().toUpperCase())
    .filter(Boolean);
  // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª—é—á–µ–≤–æ–≥–æ –±–ª–æ–∫–∞ –∏—â–µ–º –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ OCR
  const uniq = new Set();
  const result = [];
  for (const phrase of keyPhrases) {
    let best = '';
    let bestScore = -100;
    for (const line of lines) {
      // –ü—Ä–æ—Å—Ç–∞—è –º–µ—Ç—Ä–∏–∫–∞ —Å—Ö–æ–∂–µ—Å—Ç–∏: —Å–∫–æ–ª—å–∫–æ —Å–ª–æ–≤ –∏–∑ –∫–ª—é—á–∞ –µ—Å—Ç—å –≤ —Å—Ç—Ä–æ–∫–µ
      const words = phrase.split(' ');
      let score = 0;
      for (const w of words) if (line.includes(w)) score++;
      if (score > bestScore) {
        bestScore = score;
        best = line;
      }
    }
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–æ–≤–ø–∞–ª–æ —Ö–æ—Ç—è –±—ã 2 —Å–ª–æ–≤–∞ –∏ –µ—â—ë –Ω–µ –±—ã–ª–æ —Ç–∞–∫–æ–≥–æ –±–ª–æ–∫–∞
    if (bestScore >= 2 && !uniq.has(phrase)) {
      result.push(phrase);
      uniq.add(phrase);
    }
  }
  // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ ‚Äî fallback: —Ñ–∏–ª—å—Ç—Ä—É–µ–º –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
  if (result.length === 0) {
    // –§–∏–ª—å—Ç—Ä: —É–±–∏—Ä–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–µ, –º—É—Å–æ—Ä–Ω—ã–µ, –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è —Å—Ç—Ä–æ–∫–∏
    const filtered = lines.filter(line =>
      line.length >= 8 &&
      /[–ê-–Ø–Å]{2,}/.test(line) && // –º–∏–Ω–∏–º—É–º 2 —Ä—É—Å—Å–∫–∏–µ –±—É–∫–≤—ã
      /[A-Z–ê-–Ø–Å0-9]/.test(line) && // –µ—Å—Ç—å –±—É–∫–≤—ã/—Ü–∏—Ñ—Ä—ã
      !/^[-_=]+$/.test(line) && // –Ω–µ —Ç–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª—ã
      line.replace(/[^–ê-–Ø–Å]/g, '').length >= 0.5 * line.length // –Ω–µ –º–µ–Ω–µ–µ 50% –±—É–∫–≤
    );
    // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏
    const uniqFiltered = [...new Set(filtered)];
    // –ï—Å–ª–∏ —Å–æ–≤—Å–µ–º –Ω–∏—á–µ–≥–æ ‚Äî fallback: –±–µ—Ä—ë–º –ª—é–±—ã–µ —Å—Ç—Ä–æ–∫–∏ –Ω–µ –∫–æ—Ä–æ—á–µ 5 —Å–∏–º–≤–æ–ª–æ–≤
    if (uniqFiltered.length === 0) {
      const anyLines = [...new Set(lines.filter(line => line.length >= 5))];
      return anyLines.slice(0, 3).join('\n');
    }
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–æ 5 –Ω–∞–∏–±–æ–ª–µ–µ –¥–ª–∏–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫
    return uniqFiltered.sort((a, b) => b.length - a.length).slice(0, 5).join('\n');
  }
  return result.join('\n');
}

// --- –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ HTML –¥–ª—è Telegram ---
function escapeHTML(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–∞ –ø–æ —Å–ª—É—á–∞–π–Ω–æ–º—É –º–∞—Ç–µ—Ä–∏–∞–ª—É (–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ "–°–∫–∞–∂–∏ –ø—Ä–∏–≤–µ—Ç")
bot.action("generate_test", async (ctx) => {
  try {
    await streamAIResponse("–°–∫–∞–∂–∏ –ø—Ä–∏–≤–µ—Ç", ctx);
  } catch (err) {
    logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∞: " + err.message);
    await ctx.reply(ui.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∞: " + err.message));
  }
});

// –ö–Ω–æ–ø–∫–∞ "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ö—ç—à–∞" ‚Äî —Å—Ç–∞–≤–∏—Ç –∑–∞–¥–∞—á—É –≤ –æ—á–µ—Ä–µ–¥—å
bot.action("generate_cache", async (ctx) => {
  cacheQueue.push({ ctx });
  await ctx.answerCbQuery("‚è≥ –ó–∞–¥–∞—á–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å.");
  await sendProgress(ctx, `–í–∞—à–∞ –∑–∞–¥–∞—á–∞ –Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫—ç—à–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å. –ü–æ–∑–∏—Ü–∏—è: ${cacheQueue.length}`);
  processCacheQueue();
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫
async function uploadToYandexDisk(localFilePath, remoteFilePath, ctx) {
  try {
    await yadisk.uploadFile(localFilePath, remoteFilePath);
    logAndNotify(`–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω –Ω–∞ –Ø.–î–∏—Å–∫: ${remoteFilePath}`, ctx);
  } catch (error) {
    logger.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ –Ø.–î–∏—Å–∫: " + error.message);
    logAndNotify(ui.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ –Ø.–î–∏—Å–∫: " + error.message), ctx);
    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫.");
  }
}

function saveToCacheAndSync(question, answer, ctx = null) {
  saveToCacheHistory(question, answer);

  const localPath = path.join(cachePath, "dataset.json");
  const remotePath = "/bot_cache/dataset.json";
  exportCacheToJsonFile(localPath, async (err) => {
    if (!err) {
      try {
        await uploadCacheJsonToYadisk(yadisk, localPath, remotePath);
        if (ctx) await ctx.reply(ui.cacheSynced);
        notifyAdmin(ui.cacheSynced);
        logger.info("–ö—ç—à —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω!");
      } catch (e) {
        if (ctx) await ctx.reply(ui.error(e.message));
        notifyAdmin(ui.error(e.message));
        logger.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫—ç—à–∞ –Ω–∞ –Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫: " + e.message);
      }
    } else {
      if (ctx) await ctx.reply(ui.error(err.message));
      notifyAdmin(ui.error(err.message));
      logger.error("–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –∫—ç—à–∞ –≤ JSON: " + err.message);
    }
  });
}

// --- –£–¢–ò–õ–ò–¢–ê: –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ Telegram –≤ temp ---
async function downloadFile(file, userId) {
  const tempPath = path.join(__dirname, 'temp');
  await fs.ensureDir(tempPath);
  const ext = path.extname(file.file_path || '.jpg');
  const fileName = `${userId}_${Date.now()}${ext}`;
  const dest = path.join(tempPath, fileName);
  const fileLink = await bot.telegram.getFileLink(file.file_id);

  const res = await fetch(fileLink.href);
  if (!res.ok) throw new Error(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: ${res.statusText}`);
  // –î–ª—è node >=18 –∏—Å–ø–æ–ª—å–∑—É–µ–º arrayBuffer, –¥–ª—è node-fetch@2 ‚Äî buffer
  let buffer;
  if (typeof res.arrayBuffer === 'function') {
    buffer = Buffer.from(await res.arrayBuffer());
  } else {
    buffer = await res.buffer();
  }
  await fs.writeFile(dest, buffer);
  return dest;
}

// --- –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ –∏ –ø–æ–ª–µ–∑–Ω–æ—Å—Ç–∏ OCR-—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ---
function evalHumanReadableScoreV2(text) {
  if (!text || typeof text !== 'string') return 0;
  const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  if (!lines.length) return 0;
  const totalChars = text.length;
  const ruChars = (text.match(/[–ê-–Ø–∞-—è–Å—ë]/g) || []).length;
  const ruRatio = ruChars / (totalChars || 1);
  const uniqLines = new Set(lines).size;
  // –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏ –±–∏–∑–Ω–µ—Å-—Ç–µ—Ä–º–∏–Ω—ã
  const bonusWords = [
    "–ê–ö–¢–ò–í–ò–†–£–ô–¢–ï", "–°–ö–ê–ß–ê–ô–¢–ï", "–ü–†–ò–õ–û–ñ–ï–ù–ò–ï", "–ú–ê–ì–ê–ó–ò–ù", "–°–ï–†–í–ò–°–´", "–≠–í–û–¢–û–†",
    "–ò–ù–ù", "–û–ì–†–ù", "–ê–î–†–ï–°", "–ö–û–ù–¢–ê–ö–¢", "–¢–ï–õ–ï–§–û–ù", "EMAIL", "E-MAIL",
    "–ö–õ–Æ–ß", "–ï–ì–ê–ò–°", "–¢–û–†–ì–û–í–õ–ò", "–ë–£–•–ì–ê–õ–¢–ï–†–ò–Ø", "–§–ò–û", "–û–û–û", "–ò–ü", "–û–ê–û"
  ];
  let bonus = 0;
  let phoneCount = 0, emailCount = 0, innCount = 0, addressCount = 0;
  const phoneRegex = /\+?\d[\d\s\-()]{7,}/g;
  const emailRegex = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i;
  const innRegex = /\b\d{10,12}\b/;
  const addressRegex = /(–≥\.|—É–ª\.|–ø—Ä–æ—Å–ø\.|–ø–µ—Ä\.|–¥\.|–æ—Ñ–∏—Å|–∫–æ—Ä–ø—É—Å|–∫–≤\.|–ø–ª\.|–æ–±–ª\.|—Ä–∞–π–æ–Ω|—Ä-–Ω|–ø–æ—Å–µ–ª–æ–∫|–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω)/i;
  // –ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä–æ–∫
  lines.forEach(line => {
    if (phoneRegex.test(line)) phoneCount++;
    if (emailRegex.test(line)) emailCount++;
    if (innRegex.test(line)) innCount++;
    if (addressRegex.test(line)) addressCount++;
    for (const w of bonusWords) if (line.toUpperCase().includes(w)) bonus += 0.1;
  });
  // –ú—É—Å–æ—Ä–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
  const noisyLines = lines.filter(l => l.length < 5 || (l.replace(/[–ê-–Ø–∞-—è–Å—ë0-9]/gi, '').length / l.length) > 0.5).length;
  // –ë–æ–Ω—É—Å –∑–∞ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –∏ –ø–æ–ª–µ–∑–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
  const diversityBonus = uniqLines >= 3 ? 0.5 : 0;
  // –ò—Ç–æ–≥–æ–≤–∞—è —Ñ–æ—Ä–º—É–ª–∞
  let score = (
    ruRatio * 2 +
    Math.min(lines.length / 10, 1) +
    Math.min(uniqLines / lines.length, 1) +
    bonus +
    diversityBonus +
    phoneCount * 0.7 +
    emailCount * 0.7 +
    innCount * 0.5 +
    addressCount * 0.5 -
    noisyLines * 0.2
  );
  // –®—Ç—Ä–∞—Ñ –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ –∏ –æ–Ω–∞ –∫–æ—Ä–æ—Ç–∫–∞—è
  if (lines.length === 1 && lines[0].length < 10) score -= 0.5;
  return score;
}

// --- –ü–æ–¥—Ä–æ–±–Ω—ã–π –ª–æ–≥ –≤—ã–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ---
function selectBestOcrResultV2(allResults, semanticResult, cleanedSemantic, humanResult) {
  const candidates = [];
  allResults.forEach((r, i) => candidates.push({
    text: r,
    label: `–®–∞–±–ª–æ–Ω ${i + 1}`,
    score: evalHumanReadableScoreV2(r)
  }));
  candidates.push({ text: semanticResult, label: '–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–±–æ—Ä–∫–∞', score: evalHumanReadableScoreV2(semanticResult) });
  candidates.push({ text: cleanedSemantic, label: '–ü–æ—Å–ª–µ LanguageTool', score: evalHumanReadableScoreV2(cleanedSemantic) });
  candidates.push({ text: humanResult, label: '–§–∏–Ω–∞–ª—å–Ω—ã–π (humanReadableAssemble)', score: evalHumanReadableScoreV2(humanResult) });
  candidates.sort((a, b) => b.score - a.score);
  logger.info('[BOT] --- –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ OCR ---');
  candidates.forEach(c => {
    logger.info(`[BOT] ${c.label}: score=${c.score.toFixed(2)}\n${c.text}\n---`);
  });
  logger.info(`[BOT] –õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${candidates[0].label} (–æ—Ü–µ–Ω–∫–∞: ${candidates[0].score.toFixed(2)})`);
  logger.info(`[BOT] –õ—É—á—à–∏–π —Ç–µ–∫—Å—Ç:\n${candidates[0].text}`);
  return candidates[0].text;
}

// --- –í –º–µ—Å—Ç–µ, –≥–¥–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç ---
function sendBestOcrResult(ctx, bestResult) {
  return ctx.replyWithHTML(
    `<b>üìã –ò—Ç–æ–≥–æ–≤—ã–π —Ç–µ–∫—Å—Ç —Å —Ñ–æ—Ç–æ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±–ª–∏–∑–∫–æ –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É)</b>\n\n<pre>${escapeHTML(bestResult)}</pre>`
  ).then(() => {
    logger.info(`[BOT] –í—Å–µ —à–∞–±–ª–æ–Ω—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã. –ò—Ç–æ–≥–æ–≤–∞—è —Å–±–æ—Ä–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.`);
  }).catch(e => {
    logger.error(`[BOT] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é: ${e.message}`);
  });
}

module.exports = {
    app,
    bot,
    mainMenuKeyboard,
    parseDocxToText,
    splitTextByLength,
    saveToCacheAndSync,
    fuzzyFindInYandexDisk
  };
