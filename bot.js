const { Telegraf, Markup } = require("telegraf");
const express = require("express");
const path = require("path");
const fs = require("fs-extra");
const mammoth = require("mammoth");
const gpt4all = require("gpt4all");
require("dotenv").config();
const os = require("os");

// –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const modelDir = path.join(os.homedir(), ".cache", "gpt4all");
const finalModelPath = path.join(modelDir, "Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf");
const materialsPath = path.join(__dirname, "materials");
const PORT = process.env.PORT || 3000;
const webAppUrl = `http://89.169.131.216:${PORT}`;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ Express
const bot = new Telegraf(process.env.BOT_TOKEN);
const app = express();

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
app.use("/static", express.static(path.join(__dirname, "static")));

// –ë–∞–∑–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
async function parseDocxToText(filePath) {
    try {
        const result = await mammoth.extractRawText({ path: filePath });
        return result.value.trim();
    } catch (err) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ —Ñ–∞–π–ª–∞ ${filePath}:`, err);
        return "";
    }
}

async function parseDocxToHtml(filePath) {
    try {
        const result = await mammoth.convertToHtml({ path: filePath });
        return result.value.trim();
    } catch (err) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ —Ñ–∞–π–ª–∞ ${filePath}:`, err);
        return "<p>–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞.</p>";
    }
}

async function getFilesFromRoot() {
    try {
        const items = await fs.readdir(materialsPath);
        return items.filter((item) => item.endsWith(".docx"));
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤:", err);
        return [];
    }
}

// –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å AI
let gpt4allModel = null;

async function initGPT4AllModel() {
    try {
        console.log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è GPT4All –º–æ–¥–µ–ª–∏...");
        const model = new gpt4all.LLModel(finalModelPath);

        return {
            generate: async (prompt) => {
                try {
                    return await model.prompt(prompt);
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:", error);
                    return null;
                }
            }
        };
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ GPT4All:", error);
        return null;
    }
}

async function generateAIQuestions(text) {
    try {
        if (!gpt4allModel) {
            gpt4allModel = await initGPT4AllModel();
        }
        if (!gpt4allModel) {
            throw new Error("–ú–æ–¥–µ–ª—å GPT4All –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.");
        }
        const prompt = `–°–æ–∑–¥–∞–π 1 –≤–æ–ø—Ä–æ—Å —Å 4 –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –æ—Ç–≤–µ—Ç–∞ –ø–æ —Ç–µ–∫—Å—Ç—É: ${text}`;
        return await gpt4allModel.generate(prompt);
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–æ–ø—Ä–æ—Å–æ–≤ —á–µ—Ä–µ–∑ AI:", err);
        throw err;
    }
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞
bot.start(async (ctx) => {
    await ctx.reply(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª—ã.",
        Markup.inlineKeyboard([
            Markup.button.callback("üìÇ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª—ã", "open_materials"),
            Markup.button.callback("üìù –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç", "generate_test"),
        ])
    );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª—ã"
bot.action("open_materials", async (ctx) => {
    const files = await getFilesFromRoot();

    if (files.length === 0) {
        return ctx.reply("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤.");
    }

    const buttons = files.map((file) => [
        Markup.button.callback(file, `material:${file}`),
    ]);

    await ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª:", Markup.inlineKeyboard(buttons));
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
bot.action(/^material:(.+)$/, async (ctx) => {
    const fileName = ctx.match[1];
    const filePath = path.join(materialsPath, fileName);

    if (!fs.existsSync(filePath)) {
        return ctx.reply("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.");
    }

    const url = `${webAppUrl}/article/${encodeURIComponent(fileName)}`;

    await ctx.reply(
        `–û—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª "${fileName}" —á–µ—Ä–µ–∑ Web App:`,
        Markup.inlineKeyboard([
            Markup.button.url("–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª", url),
            Markup.button.callback("üîô –ù–∞–∑–∞–¥", "open_materials"),
        ])
    );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç"
bot.action("generate_test", async (ctx) => {
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Operation Timeout")), 60000);
    });

    try {
        await ctx.reply(
            "–ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ—Å—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ..."
        );

        await Promise.race([
            (async () => {
                const files = await getFilesFromRoot();
                if (files.length === 0) {
                    throw new Error("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∞.");
                }

                const randomFile = files[Math.floor(Math.random() * files.length)];
                const filePath = path.join(materialsPath, randomFile);

                const result = await parseDocxToText(filePath);
                if (!result) {
                    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è —Ç–µ—Å—Ç–∞.");
                }

                const test = await generateAIQuestions(result);
                await ctx.reply(`–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ "${randomFile}":\n\n${test}`);
            })(),
            timeoutPromise,
        ]);
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∞:", err);
        if (err.message === "Operation Timeout") {
            await ctx.reply("–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
        } else {
            await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
        }
    }
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤
bot.launch()
    .then(() => console.log("–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω!"))
    .catch((err) => console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞:", err));

app.listen(PORT, () => {
    console.log(`Express-—Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
});

